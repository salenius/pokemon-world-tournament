{-# LANGUAGE OverloadedStrings #-}

module Data.Pokemon where

import Data.Pokemon.Attr
import Data.Aeson
import Data.ByteString.Lazy

data Pokemon a b = Pokemon Name Attr a b

type Name = String

-- | Parses a Pokemon from a JSON string that generated by the combine-data.sh script.
-- Fails if the string does not conform to the schema. The user is expected to provide
-- an implementation of a FromJSON type class instance for the first type variable
-- that can parse attributes that the parser for the Attr data type ignores.
fromJson :: (FromJSON a) => ByteString -> Maybe (Pokemon a ())
fromJson txt = do
  Pokemon n _ s ()  <- decode txt
  a                 <- decode txt
  return $ Pokemon n a s ()

instance (FromJSON a, FromJSON b) => FromJSON (Pokemon a b) where
  parseJSON txt = flip (withObject "pokemon") txt $ \o -> do
      name <- o .: "name"
      spec <- parseJSON txt
      indv <- parseJSON txt
      return $ Pokemon name dflt spec indv

  
-- | Creates a Pokemon with the same Attr as would be created by the combine-data.sh
-- script and filtering with a key == 'ditto', but the result is guaranteed not to fail
-- and thus it can unwrapped from the Either data type. The user can use this to unwrap
-- other Pokemon created by the `fromJson` function if they can be certain that
-- their JSON string is correctly formatted and contains the correct data.
ditto :: a -> b -> Pokemon a b
ditto a = Pokemon "ditto" dflt a

-- | Transforms Pokemon's form/species specific values from an data type to another.
-- Equivalent to `first` function of the Bifunctor class.
spcMap :: (Name -> a -> b) -> Pokemon a c -> Pokemon b c
spcMap f (Pokemon n a s i) = Pokemon n a (f n s) i

-- | Transforms Pokemon's individual data from an data type to another while
-- potentially using information of the Attr data and the speices/form specific data.
-- If the arguments Attr and a are ignored, functionally equivalent to `fmap` of
-- the Functor class.
indMap :: (Attr -> a -> b -> c) -> Pokemon a b -> Pokemon a c
indMap f (Pokemon n a s i) = Pokemon n a s (f a s i)

-- | Sets Pokemon's attributes while using information about the Pokemon's species/form
-- specific data.
atrMap :: (a -> Attr -> Attr) -> Pokemon a b -> Pokemon a b
atrMap f (Pokemon n a s i) = Pokemon n (f s a) s i

-- | Flattens Pokemon by its species/form specific data. The user should implement a
-- monoid instance for the individual specific data type b such that either x <> y = x
-- or x <> y = y
transform :: Semigroup b => Pokemon (Pokemon a b) b -> Pokemon a b
transform (Pokemon _ _ (Pokemon n a s i') i) = Pokemon n a s (i <> i')

-- | Flattens Pokemon by its individual specific data. This is similar to `state` function,
-- but the difference here is that flattening happens such that the outer species/form
-- specific data is kept while the inner one is ignored.
batonPass :: Pokemon a (Pokemon a b) -> Pokemon a b
batonPass (Pokemon n a s (Pokemon _ _ _ i)) = Pokemon n a s i

-- | Observe the current individual state of the Pokemon.
state :: Pokemon a b -> b
state (Pokemon _ _ _ i) = i





